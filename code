// Type definitions for graph nodes and output structure
interface GraphNode {
  id: string;
  title: string;
  color: string;
  marker: {
    radius: number;
    lineWidth: number;
    lineColor: string;
  };
}

interface GraphData {
  data: [string, string][];
  nodes: GraphNode[];
}

// Define types for the input JSON structure (only required fields)
interface InstalledChild {
  key: string;
  version: string;
  // other fields can be defined as needed...
}

interface InputJSON {
  installed: {
    installedExpVersion: string;
    child: {
      installedChild: InstalledChild[];
      upgradeChild: any[];
      migrationChild: any[];
    };
  };
  upgrade: {
    version: string;
    child: any[]; // Detailed typing can be added if needed
  };
  migration: {
    version: string;
    child: any[];
  };
}

/**
 * Extracts and transforms input JSON to a network graph data structure
 * for a Highcharts network graph.
 *
 * Transformation Rules:
 *   - Main nodes: installed => "R150", upgrade => "R160", migration => "R170"
 *   - Main chain edges: [R150, R160] and [R160, R170]
 *   - Installed children mapping:
 *         installedTCUVersion   => "TCU"
 *         installedSHUVersion   => "SHU"
 *         installedQuickBuilderVersion => "IU1"
 *         installedTpsDisplaysVersion  => "HPi"
 *     Plus a fixed extra edge/node "TC4"
 *   - Upgrade children:
 *         Child with version "TCU7" → edge from R170
 *         Child with version "SHU8" → edges from R160 to nodes "SHU4" and "IU4"
 *         Hotfix "HF3" is transformed to "HF2" → edge from R170
 *   - Migration children:
 *         Adds fixed nodes "HUB" and "IU9" with edges from R170
 *
 * @param input - Input JSON object
 * @returns GraphData containing nodes and edges.
 */
function extractGraphData(input: InputJSON): GraphData {
  const result: GraphData = { data: [], nodes: [] };

  // Main nodes mapping
  const mainNodes = {
    installed: "R150",
    upgrade: "R160",
    migration: "R170",
  };

  // Add main nodes with specified styles
  result.nodes.push(
    {
      id: mainNodes.installed,
      title: mainNodes.installed,
      color: "#706e75",
      marker: { radius: 40, lineWidth: 2, lineColor: "red" },
    },
    {
      id: mainNodes.upgrade,
      title: mainNodes.upgrade,
      color: "#706e75",
      marker: { radius: 40, lineWidth: 2, lineColor: "red" },
    },
    {
      id: mainNodes.migration,
      title: mainNodes.migration,
      color: "#706e75",
      marker: { radius: 40, lineWidth: 2, lineColor: "green" },
    }
  );

  // Chain edges between main nodes
  result.data.push([mainNodes.installed, mainNodes.upgrade]);
  result.data.push([mainNodes.upgrade, mainNodes.migration]);

  // Mapping for installed children keys to node ids
  const installedMapping: { [key: string]: () => string } = {
    installedTCUVersion: () => "TCU",
    installedSHUVersion: () => "SHU",
    installedQuickBuilderVersion: () => "IU1",
    installedTpsDisplaysVersion: () => "HPi",
  };

  // Process installed child nodes
  if (
    input.installed &&
    input.installed.child &&
    Array.isArray(input.installed.child.installedChild)
  ) {
    input.installed.child.installedChild.forEach((item) => {
      const key = item.key;
      if (installedMapping[key]) {
        const nodeId = installedMapping[key]();
        // Add node if not already present
        if (!result.nodes.find((n) => n.id === nodeId)) {
          result.nodes.push({
            id: nodeId,
            title: nodeId,
            color: "#706e75",
            marker: { radius: 30, lineWidth: 2, lineColor: "blue" },
          });
        }
        // Create edge from installed main node to child node
        result.data.push([mainNodes.installed, nodeId]);
      }
    });
    // Add fixed extra node "TC4" and its edge
    if (!result.nodes.find((n) => n.id === "TC4")) {
      result.nodes.push({
        id: "TC4",
        title: "TC4",
        color: "#706e75",
        marker: { radius: 30, lineWidth: 2, lineColor: "blue" },
      });
    }
    result.data.push([mainNodes.installed, "TC4"]);
  }

  // Process upgrade child nodes
  if (input.upgrade && Array.isArray(input.upgrade.child)) {
    input.upgrade.child.forEach((child: any) => {
      // Process hotfixes if present
      if (child.hotFixes && Array.isArray(child.hotFixes)) {
        child.hotFixes.forEach((hotfix: any) => {
          // Transform "HF3" to "HF2"
          const hotfixNode = hotfix.version === "HF3" ? "HF2" : hotfix.version;
          if (!result.nodes.find((n) => n.id === hotfixNode)) {
            result.nodes.push({
              id: hotfixNode,
              title: hotfixNode,
              color: "#706e75",
              marker: { radius: 30, lineWidth: 2, lineColor: "blue" },
            });
          }
          // Edge from migration main node to hotfix node
          result.data.push([mainNodes.migration, hotfixNode]);
        });
      }
      // Process main upgrade child version
      if (child.version) {
        if (child.version === "TCU7") {
          if (!result.nodes.find((n) => n.id === "TCU7")) {
            result.nodes.push({
              id: "TCU7",
              title: "TCU7",
              color: "#706e75",
              marker: { radius: 30, lineWidth: 2, lineColor: "blue" },
            });
          }
          result.data.push([mainNodes.migration, "TCU7"]);
        }
        if (child.version === "SHU8") {
          // Add nodes "SHU4" and "IU4" if not already added
          ["SHU4", "IU4"].forEach((nodeId) => {
            if (!result.nodes.find((n) => n.id === nodeId)) {
              result.nodes.push({
                id: nodeId,
                title: nodeId,
                color: "#706e75",
                marker: { radius: 30, lineWidth: 2, lineColor: "blue" },
              });
            }
          });
          result.data.push([mainNodes.upgrade, "SHU4"]);
          result.data.push([mainNodes.upgrade, "IU4"]);
        }
      }
    });
  }

  // Process migration child nodes: add fixed nodes "HUB" and "IU9"
  if (input.migration && Array.isArray(input.migration.child)) {
    input.migration.child.forEach(() => {
      ["HUB", "IU9"].forEach((nodeId) => {
        if (!result.nodes.find((n) => n.id === nodeId)) {
          result.nodes.push({
            id: nodeId,
            title: nodeId,
            color: "#706e75",
            marker: { radius: 30, lineWidth: 2, lineColor: "blue" },
          });
        }
        result.data.push([mainNodes.migration, nodeId]);
      });
    });
  }

  return result;
}

// ----- Example Usage ----- //
const inputJson: InputJSON = {
  installed: {
    installedExpVersion: "R520.1",
    child: {
      installedChild: [
        {
          key: "installedTCUVersion",
          version: "TCU1",
        },
        {
          key: "installedSHUVersion",
          version: "SHU4",
        },
        {
          key: "installedQuickBuilderVersion",
          version: "QBU4",
        },
        {
          key: "installedTpsDisplaysVersion",
          version: "TPSDU1",
        },
      ],
      upgradeChild: [],
      migrationChild: [],
    },
  },
  upgrade: {
    version: "R520.2",
    child: [
      {
        hotFixes: [
          {
            order: 0,
            status: "Recommended",
            releaseId: 924,
            version: "HF3",
          },
        ],
        order: 0,
        status: "Supported",
        releaseId: 39,
        version: "TCU7",
      },
      {
        hotFixes: null,
        order: 0,
        status: "Recommended",
        releaseId: 64,
        version: "SHU8",
        packageUrl:
          "https://honeywellprocess.blob.core.windows.net/public/Support/Customer/Experion-PKS-R520-Server-HMIWeb-Update-8.zip",
      },
    ],
  },
  migration: {
    version: "R530",
    child: [
      {
        hotFixes: null,
        order: 0,
        status: "Recommended",
        releaseId: 927,
        version: "TCU2",
      },
    ],
  },
};

const graphData = extractGraphData(inputJson);
console.log(JSON.stringify(graphData, null, 2));
